<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PsyBot Control Panel</title>
    <script src="[https://cdn.jsdelivr.net/npm/chart.js](https://cdn.jsdelivr.net/npm/chart.js)"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; display: flex; flex-direction: column; min-height: 100vh; }
        header { background-color: #333; color: white; padding: 10px; display: flex; justify-content: space-between; align-items: center; }
        header h1 { margin: 0; font-size: 24px; }
        #latency { font-size: 14px; }
        .container { flex: 1; padding: 20px; display: flex; flex-direction: column; gap: 20px; }
        .controls { display: flex; gap: 10px; flex-wrap: wrap; }
        .controls button { padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }
        .controls button:hover { background-color: #0056b3; }
        .status { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .status div { font-size: 16px; }
        .chart-container { background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); height: 300px; }
        .signals { background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 5px rgba[0,0,0,0.1); max-height: 200px; overflow-y: auto; }
        footer { background-color: #333; color: white; padding: 10px; text-align: center; font-size: 14px; }
        @media (max-width: 768px) { .container { padding: 10px; } .status { grid-template-columns: 1fr; } .chart-container { height: 200px; } }
    </style>
</head>
<body>
<header>
    <h1>PsyBot Control Panel</h1>
    <div id="latency">Latency: REST: N/A ms</div> </header>
<div class="container">
    <div class="controls">
        <button onclick="startBot()">Start Bot</button>
        <button onclick="stopBot()">Stop Bot</button>
        <button onclick="getBotStatus()">Get Status</button>
        <button onclick="restartBot()">Restart Bot</button>

        <label for="strategySelect">Izaberi strategiju:</label>
        <select id="strategySelect">
            <option value="RSI">RSI</option>
            <option value="SMA">SMA</option>
            <option value="DCA">DCA</option>
            <option value="Default">Default</option>
        </select>
        <button onclick="setStrategyFromSelect()">⚙️ Primeni strategiju</button>
        <div id="status">Status će biti prikazan ovde.</div>
    </div>

    <div class="status">
        <div>Price: <span id="price">N/A</span> ETH/BTC</div>
        <div>Support: <span id="support">0</span></div>
        <div>Resistance: <span id="resistance">0</span></div>
        <div>Trend: <span id="trend">N/A</span></div>
        <div>Balance: <span id="balance">N/A</span> <span id="balanceCurrency">USDT</span></div> <div>Strategija: <span id="strategija">off</span></div>
    </div>
    <div class="trades" id="trades">
        <h3>Poslednji Trejdovi:</h3>
        <p>Nema trejdova u bazi.</p>
    </div>

</div>
<div class="chart-container">
    <canvas id="orderbookChart"></canvas>
</div>
<div class="signals" id="signals">
    <p>Nema signala</p>
</div>
<footer>
    <p>Bot Status: <span id="botStatus">Disconnected</span> | Latest Signal: <span id="latestSignal">N/A</span></p>
</footer>

<script>
    const statusDiv = document.getElementById('status');
    let chart = null;
    let lastRestPing = 0;

    // Funkcija za slanje komandi (GET i POST)
    async function sendCommand(endpoint, method = 'GET', body = null) {
        const options = { method: method };
        if (body) {
            options.headers = { 'Content-Type': 'application/json' };
            options.body = JSON.stringify(body);
        }
        try {
            const response = await fetch(endpoint, options);
            const data = await response.json();
            alert(data.status || data.message); // Prikaz statusa iz odgovora
            await updateUIFromRest(); // Uvek ažuriraj status bota nakon akcije
        } catch (error) {
            console.error(`Error with ${method} ${endpoint}:`, error);
            alert(`Greška: ${error.detail || error.message || error}`);
        }
    }

    async function fetchStatus() {
        try {
            const response = await fetch('/api/status');
            const data = await response.json();
            statusDiv.innerText = `Bot Status: ${data.status}`;
            document.getElementById('botStatus').textContent = data.status; // Ažuriraj footer status
        } catch (error) {
            console.error('Error fetching status:', error);
            statusDiv.innerText = 'Error fetching status.';
            document.getElementById('botStatus').textContent = 'Error';
        }
    }

    async function fetchBalanceAndStrategy() {
        try {
            const balanceResponse = await fetch('/api/balance');
            const balanceData = await balanceResponse.json();
            document.getElementById('balance').textContent = parseFloat(balanceData.wallet_balance).toFixed(2);
            // Strategija status mora da se vrati iz /api/status ili nekog drugog API-ja
            // Trenutno bot.get_bot_status() ne vraća strategiju, pa će ovo biti N/A
            // Za strategiju ti treba poseban endpoint, ili da status endpoint vrati i strategiju
            // Privremeno, pretpostaviću da strategiju dobijaš samo iz inputa
        } catch (error) {
            console.error('Error fetching balance or strategy:', error);
        }
    }

    async function fetchTrades() {
        try {
            const response = await fetch('/api/trades');
            const trades = await response.json();
            const tradesDiv = document.getElementById('trades');
            if (trades.length > 0) {
                tradesDiv.innerHTML = '<h3>Poslednji Trejdovi:</h3>' + trades.map(trade => `
                    <p><strong>${trade.symbol}</strong> | Cena: ${parseFloat(trade.price).toFixed(4)} | Vreme: ${trade.time} | Ishod: ${trade.outcome}</p>
                `).join('');
            } else {
                tradesDiv.innerHTML = '<p>Nema trejdova u bazi.</p>';
            }
        } catch (error) {
            console.error('Error fetching trades:', error);
            document.getElementById('trades').innerHTML = '<p>Greška pri učitavanju trejdova.</p>';
        }
    }

    function startBot() { sendCommand('/api/start', 'POST'); }
    function stopBot() { sendCommand('/api/stop', 'POST'); }
    function getBotStatus() { fetchStatus(); } // Ovo je već GET, samo poziva fetchStatus
    function restartBot() { sendCommand('/api/restart', 'POST'); }

    function setStrategyFromSelect() {
        const strategyName = document.getElementById('strategySelect').value;
        sendCommand('/api/set_strategy', 'POST', { strategy_name: strategyName });
    }

    // Uklonjena sva WebSocket logika

    function initChart() {
        const ctx = document.getElementById('orderbookChart').getContext('2d');
        chart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [
                    { label: 'Support', data: [], borderColor: 'green', fill: false, stepped: true },
                    { label: 'Resistance', data: [], borderColor: 'red', fill: false, stepped: true }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Price' } },
                    y: { title: { display: true, text: 'Volume' } }
                }
            }
        });
    }

    // Funkcija za ažuriranje UI-ja (podaci sada dolaze iz REST API poziva)
    async function updateUIFromRest() {
        await fetchStatus();
        await fetchBalanceAndStrategy();
        await fetchTrades();
        // Ovde možeš dodati i pozive za Price, Support, Resistance, Trend, Signals ako ih implementiraš kao API endpointe
        // Npr. const priceData = await fetch('/api/price').then(r => r.json()); document.getElementById('price').textContent = priceData.price;
    }

    function updateLatency() {
        const startRest = Date.now();
        fetch('/api/status')
        .then(response => {
            lastRestPing = Date.now() - startRest;
            return response.json();
        })
        .catch(error => {
            console.error('REST API error:', error);
            lastRestPing = 'N/A';
        })
        .finally(() => {
            document.getElementById('latency').textContent = `Latency: REST: ${lastRestPing} ms`;
        });
    }

    // Učitaj inicijalni status i ostale podatke kada se stranica učita
    document.addEventListener('DOMContentLoaded', async () => {
        initChart();
        await updateUIFromRest(); // Pozovi funkciju za inicijalno učitavanje
        setInterval(updateUIFromRest, 5000); // Ažuriraj svakih 5 sekundi
        setInterval(updateLatency, 5000);
    });

</script>

</body>
</html>